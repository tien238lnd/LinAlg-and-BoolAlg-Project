Matrix Matrix::Invert()
{
	if(ncols != nrows)
	{
		cout << "Cannot Invert!\n";
		return *this;
	}
	//Tạo bản sao của ma trận gốc để không thay đổi ma trận gốc
	Matrix temp(*this);
	//Tạo ma trận đơn vị I
	Matrix I(ncols, ncols);

	//Điền vào ma trận đơn vị I tại đường chéo là 1, và những điểm khác là 0
	for (int i = 0; i < nrows; i++)
	{
		for (int j = 0; j < ncols; j++)
		{
			if (i == j)
				I[i][i] = 1;
			else
				I[i][j] = 0;
		}
	}

	//Chuyển về ma trận bậc thang
	for (int i = 1; i < nrows; i++)
	{
		for (int j = 0; j < i; j++)
		{
			//Tìm vị trí phần tử khác 0 đầu tiên
			int f1 = LeadingEntry(temp[j]);
			int f2 = LeadingEntry(temp[i]);

			//Nếu có một dòng bằng 0 thì chương det = 0, không thể nghịch đảo
			if (f1 == ncols || f2 == ncols)
			{
				cout << "Cannot Invert!\n";
				return *this;
			}

			//Nếu vị trí khác 0 đầu tiên của 2 hàng bằng nhau thì trừ cho hàng đang xét factor lần hàng j
			if (f1 == f2)
			{
				//factor là tỉ lệ cần trừ để vị trí f2 của hàng i = 0
				double factor = temp[i][f1] / temp[j][f1];

				//Trừ cả hàng cho factor lần hàng j
				for (int k = 0; k < ncols; k++)
				{
					temp[i][k] -= factor * temp[j][k];
					I[i][k] -= factor * I[j][k];
				}
			}

			//Nếu f1 > f2 thì ta phải hoán vị 2 hàng cho nhau
			else if (f1 > f2)
			{
				temp.SwapRows(i, j);
				I.SwapRows(i, j);
				break;
			}
		}
	}

	//Chuyển về ma trận đơn vị

	//Duyệt từ hàng thứ 2 từ dưới lên
	for (int i = nrows - 2; i >= 0; i--)
	{
		for (int j = nrows - 1; j > i; j--)
		{
			//Tìm tỉ lệ cần trừ để vị trí j của hàng i = 0
			double factor = temp[i][j] / temp[j][j];
			for (int k = 0; k < ncols; k++)
			{
				temp[i][k] -= factor * temp[j][k];
				I[i][k] -= factor * I[j][k];
			}
		}
	}

	//Chia các phần tử của hàng i cho temp[i][i] đưa temp[i][i] về 1, tức ma trận đơn vị
	for (int i = 0; i < nrows; i++)
	{
		for (int j = 0; j < ncols; j++)
		{
			I[i][j] /= temp[i][i];
		}
	}
	return I;
}